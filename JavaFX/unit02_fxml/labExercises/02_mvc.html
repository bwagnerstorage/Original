<img src="images/empty.gif" onload="doScrollTop(); this.parentNode.removeChild(this);" />

<div id="csAssignmentTitle" align="center">Model View Control Architecture (MVC)</div>

<div id="csContent"> 
<h1>MVC</h1>
<p>MVC or <strong>Model View Control</strong> is a programming pattern that is often used to design GUI programs.
   The MVC pattern allows you to separate the code in a GUI application into three fundamental parts.</p>
<ul id="csList">
  <li><p>Model - the program's data</p></li>
  <li><p>View - an interface to view and modify the data</p></li>
  <li><p>Controller - operations that can be performed on the data</p></li>
</ul>

<h3><strong>Model</strong></h3>
<p>The model represents the data, and does nothing else. The model does NOT depend on the controller or the view.</p>
<h3><strong>View</strong></h3>
<p>The view displays the model data, and sends user actions (e.g. button clicks) to the controller. The view in JavaFX is
   independent of both the model and the controller.</p>
<h3><strong>Controller</strong></h3>
<p>The controller provides model data to the view, and interprets user actions such as button clicks. It provides the event handling for 
   all events triggered by the view. The controller depends on the view and the model.</p>

<h1>Example</h1>
<p>The best way to understand MVC is to see an example.</p>
<ol id="csList">
  <li><p>Download the following NetBeans Project to your working directory and extract from the zip file:
   <a href="JavaFX/workspaces/JavaFXExercise3.zip" style="color:blue; font-size:1.2em">JavaFXExercise3</a>
</p></li>
<li><p>Open the workspace. Viewing the workspace in Projects view you see the following files.</p>
<img src="JavaFX/images/MVC1.png" class="center" width="70%"><br>

<p>In this JavaFX application I am using the MVC design pattern so I have created 3 files
   to represent each of the three fundamental parts. The <strong>Model</strong> is implemented in the file 
  MyModel.java, the <strong>View</strong> is implemented in the 
  file FXMLDocument.fxml, and the <strong>Controller</strong> is implemented in the 
  file FXMLDocumentController.java. The last two file names were automatically
  generated by the IDE, but I could have easily changed them.</p>
</li>
<li><p>Execute the program. When the window appears type a name in the textField at the top of the window
    then press the add button to add the name to the listview component.</p></li>
<li><p>Add a few more names, then close the application's window.</p></li>
<li><p>Execute the program again. The names you typed in should still be listed in the listview component.</p></li>
</ol>
<p>Lets look at each of these files to see how the MVC pattern is implemented. We will start with the Model.</p>
<h1>Model</h1>
<p>The model is responsible for the application's data. The data in this program is simply
    a list of names and is encapsulated in a class named <strong>MyModel</strong>. In a larger application 
    the model may be implemented by multiple classes.</p>
 <p>When using the MVC design pattern the model only has one job and that is to manage the
    application's data, and that's it. There should be no references to either the view or 
    the controller within its class or classes.</p>
    <p>The benefit of making the model independent of the other two parts is that the 
       model can be updated or changed without effecting the other two parts. It can also
       be tested separate from the other two.</p>
<div id="csCode"><pre>
public class MyModel 
{
    // instance variables
    private List &lt;String&gt; myList;   // list of names
    
    public MyModel()
    {
        myList = new ArrayList&lt;&gt;();
        load();
    }
    
    public void load()
    {
        try 
        {
            Scanner input = new Scanner(new File("data.txt"));
            while(input.hasNextLine())
            {
                myList.add(input.nextLine());
            }
            input.close();
        }
        catch(IOException e)
        {}
    }
    
    public void save()
    {
        try 
        {
            PrintWriter output = new PrintWriter(new File("data.txt"));
            for(String str : myList)
            {
                output.println(str);
            }
            output.close();
        }
        catch(IOException e)
        {}
    }
    
    // methods
    public void add(String str)
    {
        myList.add(str);
    }
    
    public void remove(int index)
    {
        myList.remove(index);
    }
    
    public String get(int index)
    {
        return myList.get(index);
    }
    
    public List&lt;String&gt; getList()
    {
        return myList;
    }
}
</pre></div>  
<p>Looking at the code you see that the list is maintained as an ArrayList of Strings and there
   are methods for adding and removing items from the list. The list of names are also stored
   as persistent storage in a text file. This file's data is loaded into the Arraylist 
   when the application starts and the data is stored back to the file when the 
   application's window closes.
</p>
<h1>View</h1>
<p>The view represents the user interface (UI) for the application. The view could be a 
   console window, or a GUI window, a mobile app user interface, or a web application.</p>
<p>Like the model, the view is implemented independent of the other two parts. This means the 
   view has no direct interaction with either the model or the controller.</p>
<p>The benefits of this implementation are the same as the model. The view can be updated 
   or changed without effecting the other two parts and it can also be tested independently.
</p>
<div id="csCode" style="width:870px"><pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;?import javafx.geometry.Insets?&gt;
&lt;?import javafx.scene.control.Button?&gt;
&lt;?import javafx.scene.control.ListView?&gt;
&lt;?import javafx.scene.control.TextField?&gt;
&lt;?import javafx.scene.layout.AnchorPane?&gt;

&lt;AnchorPane id="AnchorPane" prefHeight="400.0" prefWidth="400.0" xmlns="http://javafx.com/javafx/8.0.171"
               xmlns:fx="http://javafx.com/fxml/1" fx:controller="javafxexercise3.FXMLDocumentController"&gt;
    &lt;children&gt;
        &lt;Button fx:id="myButton" layoutX="293.0" layoutY="30.0" onAction="#handleButtonAction" text="Add"&gt;
            &lt;padding&gt;
                &lt;Insets bottom="5.0" left="20.0" right="20.0" top="5.0" /&gt;
            &lt;/padding&gt;
        &lt;/Button&gt;
        &lt;TextField fx:id="myTextField" layoutX="30.0" layoutY="30.0" prefHeight="27.0" prefWidth="222.0" /&gt;
        &lt;ListView fx:id="myListView" layoutX="73.0" layoutY="81.0" prefHeight="263.0" prefWidth="245.0" /&gt;
    &lt;/children&gt;
&lt;/AnchorPane&gt;  
</pre></div>
<p>Notice that I used FXML to implement the GUI interface for this application. I could have
   used JavaFX classes to implement the view. You will see why I made this 
   decision in the next unit.
</p>
<h1>Controller</h1>
<p>The controller has the responsibility of managing the interaction between the model and the view.
   All interaction between these two parts must go through the controller. The controller provides 
   model data for the view and it also provides event handling for events generated by
   the view that change the model data.</p>
   <div id="csCode"><pre>
public class FXMLDocumentController {
    
    private MyModel model = new MyModel();
    private ObservableList&lt;String&gt; observableList; 
    
    @FXML
    private TextField myTextField;
    
    @FXML
    private ListView myListView;
    
    // event handler
    
   @FXML
    private void handleButtonAction(ActionEvent event) {
        String text = myTextField.getText();
        myTextField.clear();
        observableList.add(text);
    }

    public void shutdown() {
        model.save();
    }
    
    public void initialize() {
        observableList = FXCollections.observableList(model.getList());
        myListView.setItems(observableList);
    }     
}
</pre></div>
<p>The controller is dependent upon the model and the view. You can see this dependency by looking
   at the FXMLDocumentController class's instance variables.</p>
<div id="csCode" style="width:400px"><pre>
private MyModel model = new MyModel();
private ObservableList&lt;String&gt; observableList; 

@FXML
private TextField myTextField;

@FXML
private ListView myListView;
</pre></div>
<p>The controller has a variable named <strong>model</strong> that has a reference to a MyModel object.
   This gives the controller access to the list of names maintained by the model. 
   The variables <strong>myTextField</strong> and <strong>myListView</strong> are given references 
   to the view's TextField 
  and ListView objects when the FXMLLoader class's load method is executed. This means that the
  controller has access to these two components.
</p>
<h3 style="font-size: 1.3em; font-weight: bold">ObservableList</h3>
<p>The controller has a variable that contains a reference to an ObservableList.</p>
<div id="csCode" style="width:400px"><pre>private ObservableList&lt;String&gt; observableList;</pre></div>
<p>An <strong>ObservableList</strong> is similar to other lists, in that it implements the List interface, but it has the added benefit of being 
   able to generate events when its data has been selected or modified by the view. 
   Event handlers or listeners can be registered with an observablelist so they are notified
   when these events occur.</p>
<h3>initialize Method</h3>
<p>In NetBeans, if you create a new JavaFX application using the template "JavaFX FXML Application",
<img src="JavaFX/images/NetBeansJavaFXProject.png" width="90%" class="center">
</p>NetBeans will create a controller class file like the one shown below.</p>
<div id="csCode"><pre>
public class FXMLDocumentController implements Initializable {

    // other code not shown
    
    @Override
    public void initialize(URL url, ResourceBundle rb) {
        
    }      
}
</pre></div>
<p>Notice that the class implements an interface named <strong>Initializable</strong> which declares one method 
   named <strong>initialize</strong>. With the latest version of JavaFX the implementation of this interface is no longer needed. The two parameters listed in the
   initialize method's parameter list are now automatically injected into the controller class so they are no longer needed as part of the 
   initialize method.</p>

<p>Here is how a controller class should be defined now.</p>

<div id="csCode"><pre>
public class FXMLDocumentController {

    // other code not shown
    
    public void initialize() {
        
    }      
}
    </pre></div>
<p>Notice that the implementation of the Initializable interface has been removed from the class header and the initialize method
   no longer has the two parameters. With the current version of JavaFX the FXMLLoader class automatically calls the zero parameter 
   initialize method after it injects the annotated variables with their component references. </p>
   <P>Look at the initialize method from our example.</P>

<div id="csCode" style="width:600px"><pre>
public void initialize() {
    observableList = FXCollections.observableList(model.getList());
    myListView.setItems(observableList);
}</pre></div>

<p>The first line of code uses a factory method from the FXCollections class named 
   <strong>observableList</strong> to create and return an ObservableList object.</p>
<div id="csNote"> A <strong>factory</strong> method is a static
    method that returns an instance of a class, in other words, a pre-made object. To learn why factory methods are often preferred
    over constructors click <a href="https://www.baeldung.com/java-constructors-vs-static-factory-methods" target="_blank" style="color:blue">here</a>.</div>
<p> The important part of this factory method
   call is that it takes, as a argument, a reference to the model's ArrayList by calling the MyModel method <strong>getList</strong>. This code syncs the 
   model's ArrayList with the ListView component's ObservableList. Any changes made to 
   observableList are automatically reflected in the model's ArrayList.</p>
   <p>The second line of code assigns observablelist to the ListView component myListView.</p>

   <h3 style="font-size: 1.3em; font-weight: bold">Auto Save</h3>
<p>In this exercise, I chose to save the list of names to a data file when the application's window closed. To accomplish this
   and maintain my MVC design, which has the rule that all interaction with the model needs to occur in the Controller, 
   I had to make some modifications to the <strong>start</strong> method in the application's main class <strong>JavaFXExercise3</strong>.
</p>
<div id = "csCode" style="width:675px"><pre>private FXMLDocumentController controller;
    
@Override
public void start(Stage stage) throws Exception {
    FXMLLoader loader = new FXMLLoader(getClass().getResource("FXMLDocument.fxml"));     
    Parent root = loader.load();                                                        
    controller = loader.getController();                                                 
    Scene scene = new Scene(root);                                                       
    
    stage.setScene(scene);                                                               
    stage.setOnHidden(e -> controller.shutdown());   // save model before exit           
    stage.show();                                                                        
}</pre></div>
<p>Specifically, I needed access to the Controller so that I could call a method named <strong>shutdown</strong> which then called
   another method in the MyModel class named <strong>save</strong>. This save method saved the contents of the model's ArrayList to a data file.</p>
<p>To gain access to the controller, I first had to have a reference to a FXMLLoader object that was linked to the FXML file. This is done in the
   first line of code in the start method.</p>
<div id = "csCode"><pre>FXMLLoader loader = new FXMLLoader(getClass().getResource("FXMLDocument.fxml"));</pre></div>
<p>Second, the load method was called by the loader object creating the scene graph and storing the graph's root node in a variable named root.</p>
<div id = "csCode"><pre>Parent root = loader.load();</pre></div>
<p>Once the load method finished its job of building the scene graph and creating and injecting the controller, I was then able to get a reference to the
   controller with this line of code.</p>
<div id = "csCode" style="width:400px"><pre>controller = loader.getController(); </pre></div>
<p>With the controller reference I was then able to call the MyModel method <strong>shutdown</strong> which saved the data to a file,
  maintaining my MVC design.</p>
<div id = "csCode"><pre>stage.setOnHidden(e -> controller.shutdown());   // save model before exit </pre></div>
<p>The method <strong>setOnHidden</strong> is called when the stage window has closed. It takes one parameter an EventHandler object
   so I was able to use a lambda expression.</p>

<br>
<hr>
<br>
<h1>Lab Exercise</h1>
<p>In this exercise you are going to add a remove button, that when pressed. will remove a selected name from a ListView component.
</p>
<h3 style="font-size: 1.3em; font-weight: bold">Modifying the View</h3>
<p>In the FXMLDocument file make the following changes.</p>
<ol id="csList">
    <li><p>To make room for the Remove button make these changes to the Add button.</p>
    <ul id="csList2">
        <li><p>Change its layoutX property to <strong>280.0</strong>.</p></li>
        <li><p>Change its left and right padding values to <strong>10.0</strong>.</p></li>
    </ul> 
    </li>
    <li><p>Copy the Button. Highlight from the open tag &lt;Button&gt; to the close tag &lt;/Button&gt;.
           Paste a new button just below the first button.</p>
    </li>
    <li>
        <p>Make the following changes to the second button.</p>
        <ul id="csList2">
                <li><p>Change the fx:id to <strong>Button2</strong>.</p></li>
                <li><p>Change its layoutX property to <strong>330.0</strong>.</p></li>
                <li><p>Change the onAction property to <strong>#handleRemoveAction</strong></p></li>
                <li><p>Change the text property to <strong>Remove</strong>.</p></li>
        </ul>
    </li>
</ol>
<h3 style="font-size: 1.3em; font-weight: bold">Modifying the Controller</h3>
<p>In the FXMLDocumentController file make the following changes.</p>
<ol id="csList" start="4">
        <li><p>Just below the handleButtonAction method add a new event handler method named <strong>handleRemoveAction</strong>.
               I recommend you just copy and paste the handleButtonAction method.</p></li>
        <li><p>Add the following line of code to this method.</p>
        <div id="csCode" style="width:600px"><pre>String selected = (String)myListView.getSelectionModel().getSelectedItem();</pre></div>
        <p>This code stores the selected name from the MyListView into the String variable named selected.</p>
        </li>
        <li><p>Add this line of code to method.</p>
        <div id="csCode" style="width:300px"><pre>observableList.remove(selected);</pre></div>
        <p>This code removes the selected name from the ObservableList attached to myListView. Remember, since the
                model's ArrayList is synced with the listview's ObservableList any changes made to the ObservableList will automatically be reflected
                in the ArrayList.</p>
        </li>
        <li><p>Finally add this line of code.</p>
            <div id="csCode" style="width:300px"><pre>myListView.autosize();</pre></div>
            <p>The <strong>autosize</strong> method automatically updates the size of the listview to match the size of its observableList.
               You might want to remove or comment out this line of code then run the program to see what happens if you don't use
               this method. You will need to remove a few names then add a few back.</p>
        </li>
</ol>




  <br>
</div>	

